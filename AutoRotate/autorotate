#!/bin/lua

----------
-- init --
----------

local socket = require("socket")

local x = 0
local y = 0
local angle = 0
local length = 0
local value = nil
local current = nil
local timesonvalue = 0
local maxlength = 520 -- magic value (determined by testing..)
-- set by config
local config
local pollinterval
local pollcount
local vthreshold
local delta
local pathx
local pathy

---------------
-- functions --
---------------

-- removes spaces from the begining and the end of the string
local function trim(str)
	return str:match("^%s*(.-)%s*$")
end

-- reads a value from a table generated by readini
local function readval(table,section,key,default)
	if not table then
		error("Invalid table")
	elseif not table[section] then
		return default
	else
		return table[section][key] or default
	end
end

local function readini(path)
	local output = {}
	local section = nil
	local file = io.open(path,'r')
	if not file then
		error("Config at path ".. path .. " does not exists")
		return output
	end
	for l in file:lines() do
		local line = trim(l)
		if #line > 2 and line:sub(1,1) ~= "#" then
			local sec = line:match("^%[(.*)%]$")
			if sec then
				output[sec] = output[sec] or {}
				section = sec
			else
				local k,v = line:match("^(.-)=(.*)$")
				if k and v and section then
					output[section][k]=v
				elseif not section then
					error("Statement outside of section")
				else
					error("Invalid statement")
				end
			end
		end
	end
	file:close()
	return output
end


local function updatevalues()
	-- we invert the coordinates to point up instead of down
	local filex = io.open(pathx,r)
	local tempx = - tonumber(filex:read())
	filex:close()
	local filey = io.open(pathy,r)
	local tempy = tonumber(filey:read())
	filey:close()
	length = math.sqrt(tempx*tempx + tempy*tempy)
	x = tempx / length
	y = tempy / length
	angle = math.atan(y,x)
	if angle < 0 then
		angle = angle + 2 * math.pi
	end
end

local function runcommands()
	local val = "on"..tostring(value)
	if config[val] then
		for k,v in pairs(config[val]) do
			os.execute(v)
		end
	end
	if config.onany then
		for k,v in pairs(config.onany) do
			os.execute(v)
		end
	end
end

------------
-- config --
------------

config = readini(os.getenv("HOME") .. "/.config/t4t/autorotate.ini")
pollinterval = tonumber(readval(config, "config", "pollinterval", 200))
pollcount    = tonumber(readval(config, "config", "pollcount", 3))
vthreshold   = readval(config, "config", "vthreshold",   0.75)
delta        = readval(config, "config", "delta", 30) / 180 * math.pi
-- dumb default values since the user MUST specify these for this script to run
pathx        = readval(config, "config", "pathx",        "/dev")
pathy        = readval(config, "config", "pathy",        "/dev")

---------------
-- main loop --
---------------

while true do
	updatevalues()
	if length > vthreshold * maxlength then
		-- we are "vertical enough", read values.
		if angle < delta or angle > math.pi * 2 - delta then
			if value == 90 then
				timesonvalue = timesonvalue + 1
			else
				value = 90
				timesonvalue = 0
			end
		elseif angle < math.pi / 2 + delta and angle > math.pi / 2 - delta then
			if value == 0 then
				timesonvalue = timesonvalue + 1
			else
				value = 0
				timesonvalue = 0
			end
		elseif angle < math.pi + delta and angle > math.pi - delta then
			if value == 270 then
				timesonvalue = timesonvalue + 1
			else
				value = 270
				timesonvalue = 0
			end
		elseif angle < math.pi * 3 / 2 + delta and angle > math.pi * 3 / 2 - delta then
			if value == 180 then
				timesonvalue = timesonvalue + 1
			else
				value = 180
				timesonvalue = 0
			end
		else
			value = nil
		end
		if timesonvalue == pollcount and current ~= value then
			current = value
			runcommands()
		end
	else
		value = nil
	end
	socket.sleep(pollinterval/1000)
end

